// Generated by CoffeeScript 1.6.3
var BSNode, BSTree;

BSNode = require('./BSNode');

/*
BSTree API
  - clear:boolean (void)
  - isEmpty:boolean (void)
  - add:boolean (value (integer|array of integer))
  - find:BSNode (value (integer))
  - contains:boolean (value (integer))
  - toArray:void (void)
  - toString:void
  - min:value|boolean (void)
  - max:value|boolean (void)

  - remove:boolean (value (integer))
*/


BSTree = (function() {
  function BSTree() {}

  BSTree.prototype._root = null;

  BSTree.prototype.clear = function() {
    return this._root = null;
  };

  BSTree.prototype.isEmpty = function() {
    return this._root === null;
  };

  BSTree.prototype.traverseInOrder = function(cb) {
    if (this.isEmpty()) {
      return false;
    }
    return this._traverseInOrder(this._root, cb);
  };

  BSTree.prototype._traverseInOrder = function(node, cb) {
    if (node === null) {
      return;
    }
    this._traverseInOrder(node.left, cb);
    cb(node);
    return this._traverseInOrder(node.right, cb);
  };

  BSTree.prototype.size = function() {
    var size;
    size = 0;
    this.traverseInOrder(function() {
      return size++;
    });
    return size;
  };

  /*
    The height is the number of link between the root and the farest leaf
  */


  BSTree.prototype.height = function() {
    if (this.isEmpty()) {
      return -1;
    }
    return this._height(this._root);
  };

  BSTree.prototype._height = function(node) {
    if (node === null) {
      return -1;
    }
    return Math.max(this._height(node.left), this._height(node.right)) + 1;
  };

  BSTree.prototype.add = function(value) {
    var current, _results;
    if (this.isEmpty()) {
      return this._root = new BSNode(value);
    }
    current = this._root;
    _results = [];
    while (true) {
      if (value < current.value) {
        if (current.left === null) {
          current.left = new BSNode(value);
          break;
        } else {
          _results.push(current = current.left);
        }
      } else if (value > current.value) {
        if (current.right === null) {
          current.right = new BSNode(value);
          break;
        } else {
          _results.push(current = current.right);
        }
      } else {
        break;
      }
    }
    return _results;
  };

  BSTree.prototype.find = function(value) {
    var current;
    if (this.isEmpty() === true) {
      return false;
    }
    current = this._root;
    while (current !== null && current.value !== value) {
      if (value < current.value) {
        current = current.left;
      } else {
        current = current.right;
      }
    }
    if (current === null) {
      return false;
    } else {
      return current;
    }
  };

  BSTree.prototype.contains = function(value) {
    return this.find(value) !== false;
  };

  BSTree.prototype.toArray = function() {
    var nodeArray;
    nodeArray = [];
    this.traverseInOrder(function(node) {
      return nodeArray.push(node.value);
    });
    return nodeArray;
  };

  BSTree.prototype.toString = function() {
    var nodeArray;
    nodeArray = this.toArray();
    return nodeArray.toString();
  };

  BSTree.prototype.min = function() {
    var current;
    if (this.isEmpty()) {
      return false;
    }
    current = this._root;
    while (current.left !== null) {
      current = current.left;
    }
    return current;
  };

  BSTree.prototype.max = function() {
    var current;
    if (this.isEmpty()) {
      return false;
    }
    current = this._root;
    while (current.right !== null) {
      current = current.right;
    }
    return current;
  };

  BSTree.prototype.remove = function(value) {
    if (this.isEmpty()) {
      return false;
    }
    return this._remove(this._root, value);
  };

  BSTree.prototype._find_parent = function(node, value) {
    if (node === null) {
      return false;
    }
    while (node !== null) {
      if (value < node.value) {
        if (value === node.left.value) {
          return node;
        } else {
          node = node.left;
        }
      } else {
        if (value === node.right.value) {
          return node;
        } else {
          node = node.right;
        }
      }
    }
    return false;
  };

  BSTree.prototype._find_leftmost = function(node) {
    while (node.left !== null) {
      node = node.left;
    }
    return node;
  };

  BSTree.prototype._remove = function(node, value) {
    var only_child, previous, replace, to_delete, to_delete_child_numbers;
    to_delete = this.find(value);
    if (to_delete === false) {
      return false;
    }
    previous = this._find_parent(node, value);
    to_delete_child_numbers = to_delete._getChildNumbers();
    if (to_delete_child_numbers === 0) {
      if (previous.left && previous.left.value === to_delete.value) {
        previous.left = null;
      } else {
        previous.right = null;
      }
      return true;
    } else if (to_delete_child_numbers === 1) {
      if (to_delete.left === null) {
        only_child = to_delete.right;
      } else {
        only_child = to_delete.right;
      }
      if (previous.left && previous.left.value === to_delete.value) {
        return previous.left = only_child;
      } else {
        return previous.right = only_child;
      }
    } else {
      replace = this._find_leftmost(to_delete.right);
      this._remove(to_delete, replace.value);
      to_delete.value = replace.value;
      return true;
    }
  };

  return BSTree;

})();

module.exports = BSTree;
