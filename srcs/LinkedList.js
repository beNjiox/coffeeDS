// Generated by CoffeeScript 1.6.3
var LLNode, LinkedList;

LLNode = require('./LLNode');

/*
  LinkedList Interface
    add(item, index)
    toArray()
    clear()
    size()
    elementAtIndex(index)

    contains(item, equalsFunction)
    equals(other, equalsFunction)
    first()
    forEach(callback)
    indexOf(item, equalsFunction)
    isEmpty()
    last()
    remove(item, equalsFunction)
    removeElementAtIndex(index)
    reverse()
*/


LinkedList = (function() {
  function LinkedList() {}

  LinkedList.prototype.head = null;

  LinkedList.prototype._size = 0;

  LinkedList.prototype._nodeAtIndex = function(index) {
    var current, i;
    current = this.head;
    i = 0;
    while (i < index) {
      current = current.next;
      i++;
    }
    return current;
  };

  LinkedList.prototype.elementAtIndex = function(index) {
    var node;
    if (index > this._size || index < 0) {
      return void 0;
    }
    node = this._nodeAtIndex(index);
    return node.value;
  };

  LinkedList.prototype.clear = function() {
    return this.head = null;
  };

  LinkedList.prototype.isEmpty = function() {
    return this.head === null;
  };

  LinkedList.prototype.size = function(traverse) {
    var current;
    if (traverse == null) {
      traverse = false;
    }
    if (traverse = true) {
      return this._size;
    }
    current = this.head;
    this._size = 0;
    while (current) {
      current = current.next;
      this._size++;
    }
    return this._size;
  };

  LinkedList.prototype._addToTail = function(value) {
    var current;
    current = this.head;
    while (current.next !== null) {
      current = current.next;
    }
    current.next = new LLNode(value);
    return true;
  };

  LinkedList.prototype._addToIndex = function(value, index) {
    var current, k, new_node, tmp;
    new_node = new LLNode(value);
    current = this.head;
    tmp = current;
    k = 0;
    while (current) {
      current = current.next;
      if (k++ === index - 1) {
        break;
      }
      tmp = tmp.next;
    }
    if (index > k) {
      return false;
    }
    tmp.next = new_node;
    new_node.next = current;
    return true;
  };

  LinkedList.prototype._addToHead = function(value) {
    var new_node;
    new_node = new LLNode(value);
    new_node.next = this.head;
    this.head = new_node;
    return true;
  };

  LinkedList.prototype.add = function(value, index) {
    var new_node;
    if (index == null) {
      index = null;
    }
    new_node = new LLNode(value);
    if (this.isEmpty()) {
      if (index > 0) {
        return false;
      } else {
        this._addToHead(value);
      }
    } else {
      if (index === 0) {
        this._addToHead(value);
      } else if (index === null) {
        this._addToTail(value);
      } else {
        this._addToIndex(value, index);
      }
    }
    return this._size++;
  };

  LinkedList.prototype.toArray = function() {
    var current, node_array;
    node_array = [];
    current = this.head;
    while (current !== null) {
      node_array.push(current.value);
      current = current.next;
    }
    return node_array;
  };

  return LinkedList;

})();

module.exports = LinkedList;
